\documentclass[a4paper]{article}

\begin{document}

\section{Introduction}

Habeas is to be a language based directly on linear logic.
The language will have a construct for each of the derivation rules of LL.
The rules are treated below.

\section{General notes about the rules}

Because of the difference in semantics between commas occurring on the
left and on the right side of the turnstiles, we will here write the
right-hand ones as semicolons instead, in an attempt to reduce risk of
confusing ourselves.

\paragraph{Concepts.} Central concepts regarding how the rules of
linear logic are to be translated into programming language constructs
are: types, variables, and values. These are as known from other
programming languages.

As it turns out, in linear logic there is an additional useful concept
which we will call \emph{activation records}.  This term, too, is
known from other programming languages, but activation records are
perhaps more visible at the low level in linear logic.

\paragraph{How to read the rules.} A raw type rule typically looks like this:
$$
{\Sigma,A \vdash B;\Delta}\over{\Sigma,A' \vdash B';\Delta}
$$

The mathematical reading of this is, ``if we can prove ${\Sigma,A
  \vdash B;\Delta}$, then we can prove ${\Sigma,A' \vdash B';\Delta}$''.


The interpretation of this rule as a programming language construct is
somewhat different:
\begin{quote}
  ''Starting with a value of type $A'$ (and possibly some other values
  $\Sigma$), we get to a state where we have a value of type $A$ (and
  still $\Sigma$, unchanged). Then control passes to some sub-part of
  the construct; when this part is done, it has left an activation
  record of type $B$ as well as some other activation records
  $\Delta$. The construct then transforms this into an activation
  record of type $B'$ (and still $\Delta$, unchanged).''
\end{quote}

Thus, the control flow is from the left-hand side of the lower rule to
the left-hand side of the upper rule (or rules -- there may be more
than one; there may even be zero); then through the steps prescribed
by whatever proof tree(s) are there to prove the upper rule(s); then
from the right-hand side of the upper rule(s) down to the right-hand
side of the lower rule.


\paragraph{The cast.} Linear logic contains four binary connectives (type operators) and
one unary operator:
\begin{center}
  \begin{tabular}{c|l|l}
    \hline
    \hline
    Operator & Name & Approximate meaning\\
    \hline
    $\otimes$ & Times & Product type\\
    $\oplus$  & Plus  & Sum type\\
    $\&$      & With  & Choice type\\
    $|$       & Par   & Independent evaluation\\
    \hline
    $\lnot$   & Not   & Resource sink\\
    \hline
  \end{tabular}
\end{center}

Each of the four binary operators have a neutral element:
\begin{center}
  \begin{tabular}{c|c|l|l}
    \hline
    \hline
    Operator & Neutral & Name & Approximate meaning\\
             & element &&\\
    \hline
    $\otimes$ & $1$    & One    & Void/unit\\
    $\oplus$  & $0$    & Zero   & Impossible to create\\
    $\&$      & $\top$ & Top    & Impossible to destroy\\
    $|$       & $\bot$ & Bottom & The terminated activation record\\
    \hline
  \end{tabular}
\end{center}

= The rules

<Per-rule: the rule itself; a short description of what goes on; impact and constraints on context/variables; syntactical construct.>

== Product type.
== Sum type.

// 'par' + negation provides a function/call mechanism.
// 'with' + negation provides a multi-return-path mechanism.





\end{document}
